;;; Model for the maze
;;;

;; Determine if there is a path from our current position to the visual-location on our left.
(p determine-path-left
    =goal>
        state determine-path
    =visual>
        - left nil
        left =left
        screen-pos =previous-pos
        id =previous-id
        screen-x =current-x
        screen-y =current-y
    =visual-location>
        screen-y =current-y
        < screen-x =current-x
    =imaginal>
        finish =finish
==>
    =goal>
        state move-attention
        previous determine-path
    +imaginal>
        finish =finish
        chosen-id =left
        chosen-direction left
        previous-pos =previous-pos
        previous-id =previous-id
    =visual>
        left-attended true
    -visual>
    =visual-location>
)

;; Determine if there is a path from our current position to the visual-location on our right.
(p determine-path-right
    =goal>
        state determine-path
    =visual>
        - right nil
        right =right
        screen-pos =previous-pos
        id =previous-id
        screen-x =current-x
        screen-y =current-y
    =visual-location>
        screen-y =current-y
        > screen-x =current-x
    =imaginal>
        finish =finish
==>
    =goal>
        state move-attention
        previous determine-path
    +imaginal>
        finish =finish
        chosen-id =right
        chosen-direction right
        previous-pos =previous-pos
        previous-id =previous-id
    =visual>
        right-attended true
    -visual>
    =visual-location>
)

;; Determine if there is a path from our current position to the visual-location upwards.
(p determine-path-up
    =goal>
        state determine-path
    =visual>
        - up nil
        up =up
        screen-pos =previous-pos
        id =previous-id
        screen-x =current-x
        screen-y =current-y
    =visual-location>
        < screen-y =current-y
        screen-x =current-x
    =imaginal>
        finish =finish
==>
    =goal>
        state move-attention
        previous determine-path
    +imaginal>
        finish =finish
        chosen-id =up
        chosen-direction up
        previous-pos =previous-pos
        previous-id =previous-id
    =visual>
        up-attended true
    -visual>
    =visual-location>
)

;; Determine if there is a path from our current position to the visual-location downwards.
(p determine-path-down
    =goal>
        state determine-path
    =visual>
        - down nil
        down =down
        screen-pos =previous-pos
        id =previous-id
        screen-x =current-x
        screen-y =current-y
    =visual-location>
        > screen-y =current-y
        screen-x =current-x
    =imaginal>
        finish =finish
==>
    =goal>
        state move-attention
        previous determine-path
    +imaginal>
        finish =finish
        chosen-id =down
        chosen-direction down
        previous-pos =previous-pos
        previous-id =previous-id
    =visual>
        down-attended true
    -visual>
    =visual-location>
)

(p check-path
    =goal>
        state check-path
    =imaginal>
        chosen-id =id
        chosen-direction =dir
    =visual>
        id =id
==>
    =goal>
        state move
    +action>
        cmd move
        direction =dir
    =imaginal>
    =visual>
)

(p check-path-fail
    =goal>
        state check-path
    =imaginal>
        chosen-id =id
        previous-pos =previous
    =visual>
        - id =id
==>
    =goal>
        state find-next
    +visual>
        cmd move-attention
        screen-pos =previous
)

(p move
    =goal>
        state move
    =action>
        current =current
    =imaginal>
        - chosen-id =current
        chosen-direction =dir
==>
    +action>
        cmd move
        direction =dir
    =imaginal>
)

(p move-finish
    =goal>
        state move
    =action>
        current =current
    =imaginal>
        chosen-id =current
==>
    =goal>
        state is-dead-end
    =imaginal>
)
