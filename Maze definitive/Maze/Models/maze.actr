;;; Model for the maze
;;;

(add-dm
   (goal state find-start)
)

;; TODO (spp production :u x) for priority.

;; Find the start.
(p find-start
    =goal>
        state find-start
    ?imaginal>
        buffer free
==>
    +visual-location>
        kind start
    =goal>
        previous find-start
        state move-attention
)

;; Encode start location in imaginal buffer and look for finish.
(p encode-start-find-finish
    =goal>
        state encode-start
    =visual-location>
    ?imaginal>
        buffer free
==>
    +imaginal>
        start =visual-location
    +visual-location>
        kind finish
    =goal>
        state encode-finish
)

;; Encode finish in imaginal buffer.
(p encode-finish
    =goal>
        state encode-finish
    =visual-location>
    =imaginal>
        start =start
==>
    +imaginal>
        start =start
        finish =visual-location
    =goal>
        state find-next-x
)

;; Move the attention to a visual location.
(p move-attention
    =goal>
        state move-attention
    =visual-location>
    ?visual>
        state free
==>
    +visual>
        cmd move-attention
        screen-pos =visual-location
)

;; What to do after attention is moved to start.
(p after-move-attention1
    =goal>
        previous find-start
        state move-attention
    =visual>
==>
    =goal>
        previous move-attention
        state encode-start
    =visual>
)

;; Is there an intersection on our current x-axis?
(p find-next-x
    =goal>
        state find-next-x
==>
    +visual-location>
        kind intersection
        :attended nil
        :nearest current
        screen-x current
    =goal>
        state find-next-y
)

;; There was no intersection on our x-axis. Check the y-axis.
(p find-next-y
    =goal>
        state find-next-y
    ?visual-location>
        buffer failure
==>
    +visual-location>
        kind intersection
        :attended nil
        :nearest current
        screen-y current
    =goal>
        state determine-path
)

;; There was an intersection on our x-axis. Determine if there is a path there.
(p check-x
    =goal>
        state find-next-y
    ?visual-location>
        buffer full
==>
    =goal>
        state determine-path
)

;; There was no intersection on our y-axis either. Back to square 1.
(p check-y
    =goal>
        state determine-path
    ?visual-location>
        buffer failure
==>
    =goal>
        state find-next-x
)

;; Determine if there is a path from our current position to the visual-location on our left.
(p determine-path-left
    =goal>
        state determine-path
    =visual-location>
        kind intersection
        screen-y current
        < screen-x current
    =visual>
        ;; TODO has left entrance?
==>
    =goal>
        state move-attention
    =visual-location>
)

;; Determine if there is a path from our current position to the visual-location on our right.
(p determine-path-right
    =goal>
        state determine-path
    =visual-location>
        kind intersection
        screen-y current
        > screen-x current
    =visual>
        ;; TODO has right entrance?
==>
    =goal>
        state move-attention
    =visual-location>
)

;; Determine if there is a path from our current position to the visual-location upwards.
(p determine-path-up
    =goal>
        state determine-path
    =visual-location>
        kind intersection
        < screen-y current
        screen-x current
    =visual>
        ;; TODO has up entrance?
==>
    =goal>
        state move-attention
    =visual-location>
)

;; Determine if there is a path from our current position to the visual-location downwards.
(p determine-path-down
    =goal>
        state determine-path
    =visual-location>
        kind intersection
        > screen-y current
        screen-x current
    =visual>
        ;; TODO has down entrance?
    =visual-location>
==>
    =goal>
        state move-attention
)

(goal-focus goal)

